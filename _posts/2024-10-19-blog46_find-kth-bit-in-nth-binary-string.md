---
layout: post
title: "#45 1545. Find Kth Bit in Nth Binary String 🧠🚀"
categories: [LeetCode, Programming]
---

In this problem, we are given a sequence of binary strings where each string is generated by concatenating the previous string, a "1", and the reversed and inverted version of the previous string. Our goal is to find the `k`th bit in the `n`th binary string!

### 📄 Problem Statement
We have two integers, `n` and `k`. The binary string `S_n` is generated as follows:

- `S1 = "0"`
- `Si = Si - 1 + "1" + reverse(invert(Si - 1))` for `i > 1`

Where `+` denotes concatenation, `reverse(x)` returns the reversed string `x`, and `invert(x)` inverts all the bits (`0` becomes `1`, and `1` becomes `0`).

Given `n` and `k`, find the `k`th bit in `S_n`.

#### Examples

**Example 1:**
```
Input: n = 3, k = 1
Output: "0"
Explanation: S3 is "0111001". The 1st bit is "0".
```

**Example 2:**
```
Input: n = 4, k = 11
Output: "1"
Explanation: S4 is "011100110110001". The 11th bit is "1".
```

### 🛠️ Basic Solution

Let's simulate the process of generating the binary strings as described in the problem. We will construct the sequence up to `S_n`, then simply access the `k`th bit in `S_n`.

#### Python Code (Basic Solution)

```python
class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        def invert(s: str) -> str:
            return ''.join('1' if ch == '0' else '0' for ch in s)

        def reverse(s: str) -> str:
            return s[::-1]

        def generate_sn(n: int) -> str:
            if n == 1:
                return "0"
            prev = generate_sn(n - 1)
            return prev + "1" + reverse(invert(prev))
        
        sn = generate_sn(n)
        return sn[k - 1]
```

### ⏳ Time Complexity of Basic Solution

The time complexity of this solution depends on the recursive generation of strings. Each string `S_n` is roughly twice the size of `S_(n-1)`, so the total length of `S_n` grows exponentially. Thus, the time complexity is:

- **Time Complexity:** O(2^n), where `n` is the depth of recursion.

This solution works but is inefficient for larger values of `n` due to the exponential growth in string length. Let's explore a more optimized solution!

### ⚡ Optimized Solution

Instead of constructing the entire string, we can use the properties of the sequence to find the `k`th bit more efficiently:

- The middle bit of `S_n` is always `"1"`.
- For positions greater than the middle, they correspond to the inverted and reversed version of the previous string. We can recursively determine whether `k` is before or after the middle and adjust accordingly.

#### Python Code (Optimized Solution)

```python
class Solution:
    def findKthBit(self, n: int, k: int) -> str:
        if n == 1:
            return "0"
        length = (1 << n) - 1  # Length of S_n
        mid = length // 2 + 1

        if k == mid:
            return "1"
        elif k < mid:
            return self.findKthBit(n - 1, k)
        else:
            return '0' if self.findKthBit(n - 1, length - k + 1) == '1' else '1'

# Example usage
sol = Solution()
print(sol.findKthBit(4, 11))  # Expected output: "1"
```

### ⏳ Time Complexity of Optimized Solution

In the optimized solution, we are using recursion to reduce the problem size at each step. The complexity is significantly improved:

- **Time Complexity:** O(n), where `n` is the depth of recursion.

### 🧮 Example Walkthrough

Let’s walk through **Example 2** (`n = 4`, `k = 11`):

1. The length of `S4` is 15.
2. The middle position is `8`. Since `k = 11` is greater than `8`, we move to the inverted, reversed portion of `S3`.
3. In `S3`, the position corresponding to `k = 11` in `S4` is `length - k + 1 = 4`. Now, we need to find the 4th bit in `S3`.
4. The middle of `S3` is `4`. The 4th bit of `S3` is `"1"`, which means the 11th bit of `S4` is also `"1"`.

### 🏁 Conclusion

We presented both a basic and an optimized solution to solve the problem of finding the `k`th bit in the `n`th binary string. While the basic solution builds the string step by step, the optimized solution leverages recursion and symmetry to efficiently find the answer with a time complexity of O(n).

